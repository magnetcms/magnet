---
title: Custom Auth Strategies
description: Implement custom authentication strategies for Supabase, Auth0, or other providers
---

# Custom Auth Strategies

Magnet's authentication system is designed to be extensible. You can implement custom strategies to integrate with external authentication providers like Supabase, Auth0, Firebase, or your own authentication system.

## Overview

The extensible auth system follows a factory pattern similar to the storage adapter system:

1. Create a class that implements the `AuthStrategy` interface
2. Register it with `AuthStrategyFactory.registerStrategy()`
3. Configure Magnet to use your strategy via the `auth.strategy` option

## AuthStrategy Interface

All custom strategies must implement the `AuthStrategy` abstract class:

```ts
import type {
  AuthConfig,
  AuthResult,
  AuthStrategy,
  AuthUser,
  LoginCredentials,
  RegisterData,
} from '@magnet/common'

export abstract class AuthStrategy {
  // Unique identifier for this strategy
  abstract readonly name: string

  // Validate a token/payload and return the authenticated user
  abstract validate(payload: unknown): Promise<AuthUser | null>

  // Authenticate user with credentials and return tokens
  abstract login(credentials: LoginCredentials): Promise<AuthResult>

  // Register a new user
  abstract register(data: RegisterData): Promise<AuthUser>

  // Validate user credentials
  abstract validateCredentials(email: string, password: string): Promise<AuthUser | null>

  // Optional: Initialize the strategy
  async initialize?(): Promise<void>

  // Optional: Refresh an access token
  async refresh?(refreshToken: string): Promise<AuthResult>

  // Optional: Logout/invalidate tokens
  async logout?(token: string): Promise<void>

  // Get the Passport strategy name for guards
  getPassportStrategyName(): string {
    return this.name
  }
}
```

### Types

```ts
interface AuthUser {
  id: string
  email: string
  role: string
  [key: string]: unknown
}

interface LoginCredentials {
  email: string
  password: string
  [key: string]: unknown
}

interface RegisterData {
  email: string
  password: string
  name: string
  role?: string
  [key: string]: unknown
}

interface AuthResult {
  access_token: string
  refresh_token?: string
  expires_in?: number
  token_type?: string
}
```

## Creating a Custom Strategy

### Step 1: Implement the Strategy

Create a new file for your strategy:

```ts
// src/strategies/supabase-auth.strategy.ts
import type {
  AuthConfig,
  AuthResult,
  AuthStrategy,
  AuthUser,
  LoginCredentials,
  RegisterData,
} from '@magnet/common'
import { createClient, SupabaseClient } from '@supabase/supabase-js'

export class SupabaseAuthStrategy implements AuthStrategy {
  readonly name = 'supabase'
  private supabase: SupabaseClient

  constructor(
    config: AuthConfig,
    _userService: unknown, // Not used for Supabase
  ) {
    // Get Supabase-specific configuration
    const supabaseUrl = config.supabaseUrl as string
    const supabaseKey = config.supabaseAnonKey as string

    this.supabase = createClient(supabaseUrl, supabaseKey)
  }

  async validate(payload: unknown): Promise<AuthUser | null> {
    // Validate Supabase JWT token
    const { data: { user } } = await this.supabase.auth.getUser(payload as string)
    if (!user) return null

    return {
      id: user.id,
      email: user.email!,
      role: user.role || 'viewer',
    }
  }

  async validateCredentials(email: string, password: string): Promise<AuthUser | null> {
    const { data, error } = await this.supabase.auth.signInWithPassword({
      email,
      password,
    })

    if (error || !data.user) return null

    return {
      id: data.user.id,
      email: data.user.email!,
      role: data.user.role || 'viewer',
    }
  }

  async login(credentials: LoginCredentials): Promise<AuthResult> {
    const { data, error } = await this.supabase.auth.signInWithPassword({
      email: credentials.email,
      password: credentials.password,
    })

    if (error) throw error

    return {
      access_token: data.session!.access_token,
      refresh_token: data.session!.refresh_token,
      expires_in: data.session!.expires_in,
      token_type: 'Bearer',
    }
  }

  async register(data: RegisterData): Promise<AuthUser> {
    const { data: authData, error } = await this.supabase.auth.signUp({
      email: data.email,
      password: data.password,
      options: {
        data: { name: data.name, role: data.role },
      },
    })

    if (error) throw error

    return {
      id: authData.user!.id,
      email: authData.user!.email!,
      role: data.role || 'viewer',
    }
  }

  getPassportStrategyName(): string {
    return 'supabase-jwt'
  }
}
```

### Step 2: Register the Strategy

Register your strategy before initializing `MagnetModule`:

```ts
// src/app.module.ts
import { AuthStrategyFactory, MagnetModule } from '@magnet/core'
import { Module } from '@nestjs/common'
import { SupabaseAuthStrategy } from './strategies/supabase-auth.strategy'

// Register custom strategy BEFORE module initialization
AuthStrategyFactory.registerStrategy('supabase', SupabaseAuthStrategy)

@Module({
  imports: [
    MagnetModule.forRoot({
      db: { uri: process.env.MONGODB_URI },
      jwt: { secret: process.env.JWT_SECRET },
      auth: {
        strategy: 'supabase',
        // Strategy-specific configuration
        supabaseUrl: process.env.SUPABASE_URL,
        supabaseAnonKey: process.env.SUPABASE_ANON_KEY,
      },
    }),
  ],
})
export class AppModule {}
```

## Configuration

The `auth` configuration object accepts:

| Property | Type | Description |
|----------|------|-------------|
| `strategy` | string | Strategy name (default: `'jwt'`) |
| `jwt` | object | JWT-specific config when using JWT strategy |
| `[key]` | unknown | Any strategy-specific configuration |

Strategy-specific options are passed directly to your strategy's constructor.

## Best Practices

### 1. Handle Errors Gracefully

Throw appropriate NestJS exceptions:

```ts
import { UnauthorizedException, ConflictException } from '@nestjs/common'

async login(credentials: LoginCredentials): Promise<AuthResult> {
  const user = await this.validateCredentials(credentials.email, credentials.password)
  if (!user) {
    throw new UnauthorizedException('Invalid credentials')
  }
  // ...
}

async register(data: RegisterData): Promise<AuthUser> {
  const existing = await this.checkUserExists(data.email)
  if (existing) {
    throw new ConflictException('Email already in use')
  }
  // ...
}
```

### 2. Use Environment Variables

Never hardcode secrets in your strategy:

```ts
constructor(config: AuthConfig) {
  this.apiKey = config.apiKey as string
  if (!this.apiKey) {
    throw new Error('API key is required for CustomAuthStrategy')
  }
}
```

### 3. Implement Token Refresh (Optional)

If your provider supports refresh tokens:

```ts
async refresh(refreshToken: string): Promise<AuthResult> {
  const { data, error } = await this.provider.refreshToken(refreshToken)
  if (error) throw new UnauthorizedException('Invalid refresh token')

  return {
    access_token: data.accessToken,
    refresh_token: data.refreshToken,
    token_type: 'Bearer',
  }
}
```

### 4. Consider Passport Integration

If you need Passport.js integration for guards, extend `PassportStrategy`:

```ts
import { PassportStrategy } from '@nestjs/passport'
import { Strategy } from 'passport-custom'

export class CustomAuthStrategy
  extends PassportStrategy(Strategy, 'custom')
  implements AuthStrategy
{
  // Your implementation
}
```

## Example: Mock Strategy

See the `apps/auth-example` directory for a complete example of a custom auth strategy implementation.

```ts
// apps/auth-example/src/strategies/mock-auth.strategy.ts
export class MockAuthStrategy implements AuthStrategy {
  readonly name = 'mock'
  private users: Map<string, User> = new Map()

  // In-memory implementation for testing/development
  async login(credentials: LoginCredentials): Promise<AuthResult> {
    const user = this.users.get(credentials.email)
    if (!user || user.password !== credentials.password) {
      throw new UnauthorizedException('Invalid credentials')
    }
    // Generate JWT token...
  }
}
```

## Troubleshooting

### Strategy Not Found

```
Error: Unknown auth strategy: "custom". Use AuthStrategyFactory.registerStrategy()
```

Make sure you register the strategy **before** importing `MagnetModule`:

```ts
// Correct: Register first
AuthStrategyFactory.registerStrategy('custom', CustomStrategy)

@Module({
  imports: [MagnetModule.forRoot({ auth: { strategy: 'custom' } })],
})
```

### Guards Not Working

If JWT guards aren't working with your custom strategy, ensure `getPassportStrategyName()` returns the correct Passport strategy name, or extend `PassportStrategy` in your implementation.
